#include <ros/ros.h>
#include <sys/socket.h>
#include <ctime>
#include <cstring>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <std_msgs/String.h>
#include <etsi_its_msgs/CPM.h>
#include <vector>
#include <mutex>
#include <ros_collision_detection/CollisionCheckResult.h>
#include <ros_collision_detection/SubjectVehicleMotion.h>
#include "udp_socket.h"
#include "all_interface_generated.h" // This was generated by `flatc`.

using namespace Gos;

#define PORT 30100
#define SERVER_ADDR "172.16.2.35"
//#define SERVER_ADDR "172.16.2.4"
#define BUFFER_SIZE 4096

/*
struct DENMTriggerMsg{
  
    Gos::DENMType denm_type;
    ulong reference_time;
    Gos::ReferencePosition event_position;
    Gos::Speed event_speed;
    Gos::Heading event_position_heading; 
    Gos::CauseCode event_type;
    Gos::CauseCode linked_cause;
};
*/

class DENM_Interface{

public: 

    void triggerDENM();
    void sendMessage();

    ros_collision_detection::ObjectMovement get_subject_vehicle_info();
    void set_subject_vehicle_info(const ros_collision_detection::ObjectMovement& veh_info);

private:
    std::mutex _m_mutex;
    UDP_Socket::socket_fd _m_soc_fd;
    flatbuffers::FlatBufferBuilder denm_builder;
    ros_collision_detection::ObjectMovement _m_sub_veh_info;
};

//Globally declared DENM object
static DENM_Interface denm_obj;



void DENM_Interface::triggerDENM() {

    sendMessage();
    sleep(1); //@todo -- remove the delay after correcting the errors
}



void DENM_Interface::sendMessage(){
   
    int sockfd;
    struct sockaddr_in server_addr, client_addr;
    //uint8_t buffer[BUFFER_SIZE];
    
    // Create a UDP socket
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }
    

    std::cout << " ---------------------------------------------------------------------------- " << std::endl;
    std::cout << "Building DENM message: " << std::endl;
  


    ::flatbuffers::Offset<Gos::ItsPduHeader> header = Gos::CreateItsPduHeader(denm_builder,2, etsi_its_msgs::ItsPduHeader::MESSAGE_ID_DENM, 1234); //@todo - sending dummy value, add the correct station id in the Cohda facility layer

    ::flatbuffers::Offset<Gos::PositionConfidenceEllipse> pos_conf = Gos::CreatePositionConfidenceEllipse(denm_builder,
                                                                                                          50,  
                                                                                                          50,
                                                                                                          50);

    ::flatbuffers::Offset<Gos::Altitude> altitude = Gos::CreateAltitude(denm_builder, _m_sub_veh_info.position.z, 100);

    ::flatbuffers::Offset<ReferencePosition> ref_pos = Gos::CreateReferencePosition(denm_builder, _m_sub_veh_info.position.x, _m_sub_veh_info.position.y, pos_conf, altitude);


    //::flatbuffers::Offset<DenmManagementContainer> denm_mgmt = CreateDenmManagementContainer(denm_builder, 0,0, 0, Termination_TRMNTN_IS_CANCELLATION, ref_pos);
    ::flatbuffers::Offset<DecentralizedEnvironmentalNotificationMessage> denm_payload = CreateDecentralizedEnvironmentalNotificationMessage(denm_builder);

    ::flatbuffers::Offset<Gos::DENMessage> denm_msg = CreateDENMessage(denm_builder, header, denm_payload);
    struct flatbuffers::Offset<Gos::DENM> denm = Gos::CreateDENM(denm_builder,Gos::DENMType_DENM_REQ_TRIGGER, denm_msg);

    flatbuffers::Offset<void> msgOption = denm.Union(); 
    ::flatbuffers::Offset<FacilityLayerReception> fac_reception_message = CreateFacilityLayerReception(denm_builder,Gos::FacilityLayerMessage_DENM,msgOption);
    
    flatbuffers::Offset<void> gossip_option = fac_reception_message.Union();
    ::flatbuffers::Offset<GossipMessage> gossip_msg = CreateGossipMessage(denm_builder,Gos::GossipType::GossipType_FacilityLayerReception,gossip_option);
    denm_builder.Finish(gossip_msg);


    uint8_t* buffer = denm_builder.GetBufferPointer();
    uint64_t size = 0;
    size = denm_builder.GetSize();

    //Verify whether the buffer is valid
    flatbuffers::Verifier verifier(buffer, size);
    bool succ = VerifyGossipMessageBuffer(verifier);
    std::cout << "gossip message verified: " << succ << std::endl;
    if (!succ) {
        std::cout << "buffer is invalid" << std::endl;
    }else{
        std::cout << "buffer is valid" << std::endl;
    }

    printf("Total size of the buffer %zu\n", size);
 
    // Configure server address
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = inet_addr(SERVER_ADDR);  // localhost

    if (sendto(sockfd, buffer, size, 0, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        perror("sendto");
        exit(1);
    }

    printf("Message sent to the server!\n");
    denm_builder.Reset();
    //close(sockfd);
}

ros_collision_detection::ObjectMovement DENM_Interface::get_subject_vehicle_info(){
    std::lock_guard<std::mutex> _r_lock(_m_mutex);
    return _m_sub_veh_info;
}
void DENM_Interface::set_subject_vehicle_info(const ros_collision_detection::ObjectMovement& veh_info){

    std::lock_guard<std::mutex> _w_lock(_m_mutex);
    _m_sub_veh_info = veh_info;
}



void ego_position_Callback(const ros_collision_detection::SubjectVehicleMotion::ConstPtr& msg){

    std::cout << " ============== ego position received ====================== " << std::endl;
    denm_obj.set_subject_vehicle_info(msg->vehicle_movement);
    std::cout << "object id: " << denm_obj.get_subject_vehicle_info().id << std::endl;

}


void collision_warning_Callback(const ros_collision_detection::CollisionCheckResult::ConstPtr& msg){

    std::cout << " ========= Collision Warning message received ==================" << std::endl;
    //std::cout << *msg << std::endl;
     ros_collision_detection::ObjectMovement ego_pos = denm_obj.get_subject_vehicle_info();
    //std::cout << " ___ printing the latest ego position: " << ego_pos << std::endl;

    using CollResult = ros_collision_detection::CollisionCheckResult;

    switch (msg->result_type)
    {
    case CollResult::RESULT_IGNORE :
        std::cout << "RESULT_IGNORE" << std::endl; 
        break;
    case CollResult::RESULT_CLOSE_MONITORING :
        std::cout << "RESULT_CLOSE_MONITORING" << std::endl;
        break;
    case CollResult::RESULT_WARNING :
        std::cout << "RESULT_WARNING" << std::endl;
        break;
    case CollResult::RESULT_ALERT :
        std::cout << "RESULT_ALERT" << std::endl;
        denm_obj.triggerDENM();
        break;
    default:
        break;
    }
}



int main(int argc, char** argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, "denm_send_node");

    // Create a ROS node handle
    ros::NodeHandle nh;

    // Create a ROS subscriber
    //ros::Subscriber sub = nh.subscribe("cpm_provided", 10, &serialize_cpm);

    ros::Subscriber sub_ego_pos = nh.subscribe("ego_position", 10, &ego_position_Callback);
    ros::Subscriber sub_colln_warning = nh.subscribe("collision_warning", 10, &collision_warning_Callback);

    // ROS main loop
    ros::spin();

    return 0;
}
